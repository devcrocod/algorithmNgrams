========================= CLASS #1 =============================
(109) {13481} [13613]: Setup You will want to do the I/O initialization(*) before you get into libpng, so if it doesn't work, you don't have much to undo.
(642) {112534} [112667]: Setup You will want to do the I/O initialization before you get into libpng, so if it doesn't work, you don't have anything to undo.
*****************************************************************
========================= CLASS #2 =============================
(116) {14400} [14506]: (*): If you are not using the standard I/O functions, you will need to replace them with custom functions.
(643) {112668} [112777]: If you are not using the standard I/O functions, you will need to replace them with custom writing functions.
*****************************************************************
========================= CLASS #3 =============================
(117) {14508} [14552]: See the discussion under Customizing libpng.
(644) {112779} [112823]: See the discussion under Customizing libpng.
*****************************************************************
========================= CLASS #4 =============================
(118) {14558} [14894]: FILE *fp = fopen(file_name, "rb"); if (!fp) { return (ERROR); } if (fread(header, 1, number, fp) != number) { return (ERROR); } is_png = !png_sig_cmp(header, 0, number); if (!is_png) { return (NOT_PNG); } Next, png_struct and png_info need to be allocated and initialized.
(645) {112829} [112969]: FILE *fp = fopen(file_name, "wb"); if (!fp) return (ERROR); Next, png_struct and png_info need to be allocated and initialized.
*****************************************************************
========================= CLASS #5 =============================
(123) {15535} [16573]: png_structp png_ptr = png_create_read_struct (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr, user_error_fn, user_warning_fn); if (!png_ptr) return (ERROR); png_infop info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL); return (ERROR); } If you want to use your own memory allocation routines, use a libpng that was built with PNG_USER_MEM_SUPPORTED defined, and use png_create_read_struct_2() instead of png_create_read_struct(): png_structp png_ptr = png_create_read_struct_2 (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr, user_error_fn, user_warning_fn, (png_voidp) user_mem_ptr, user_malloc_fn, user_free_fn); The error handling routines passed to png_create_read_struct() and the memory alloc/free routines passed to png_create_struct_2() are only necessary if you are not using the libpng supplied error handling and memory alloc/free functions.
(604) {105966} [106552]: */ int initialize_png_reader() { png_ptr = png_create_read_struct (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr, user_error_fn, user_warning_fn); if (!png_ptr) return (ERROR); info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL); return (ERROR); } if (setjmp(png_jmpbuf(png_ptr))) { png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL); return (ERROR); } /* This one's new.
(650) {113370} [114196]: png_structp png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr, user_error_fn, user_warning_fn); if (!png_ptr) return (ERROR); png_infop info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { png_destroy_write_struct(&png_ptr, (png_infopp)NULL); return (ERROR); } If you want to use your own memory allocation routines, define PNG_USER_MEM_SUPPORTED and use png_create_write_struct_2() instead of png_create_write_struct(): png_structp png_ptr = png_create_write_struct_2 (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr, user_error_fn, user_warning_fn, (png_voidp) user_mem_ptr, user_malloc_fn, user_free_fn); After you have these structures, you will need to set up the error handling.
*****************************************************************
========================= CLASS #6 =============================
(124) {16575} [16651]: When libpng encounters an error, it expects to longjmp back to your routine.
(651) {114198} [114276]: When libpng encounters an error, it expects to longjmp() back to your routine.
*****************************************************************
========================= CLASS #7 =============================
(125) {16653} [16727]: Therefore, you will need to call setjmp and pass your png_jmpbuf(png_ptr).
(652) {114278} [114353]: Therefore, you will need to call setjmp() and pass the png_jmpbuf(png_ptr).
*****************************************************************
========================= CLASS #8 =============================
(126) {16729} [16887]: If you read the file from different routines, you will need to update the longjmp buffer every time you enter a new routine that will call a png_*() function.
(653) {114355} [114519]: If you write the file from different routines, you will need to update the png_jmpbuf(png_ptr) every time you enter a new routine that will call a png_*() function.
*****************************************************************
========================= CLASS #9 =============================
(127) {16889} [16987]: See your documentation of setjmp/longjmp for your compiler for more information on setjmp/longjmp.
(654) {114521} [114619]: See your documentation of setjmp/longjmp for your compiler for more information on setjmp/longjmp.
*****************************************************************
========================= CLASS #10 =============================
(128) {16989} [17123]: See the discussion on libpng error handling in the Customizing Libpng section below for more information on the libpng error handling.
(655) {114621} [114755]: See the discussion on libpng error handling in the Customizing Libpng section below for more information on the libpng error handling.
*****************************************************************
========================= CLASS #11 =============================
(131) {17511} [17705]: If you would rather avoid the complexity of setjmp/longjmp issues, you can compile libpng with PNG_NO_SETJMP, in which case errors will result in a call to PNG_ABORT() which defaults to abort().
(656) {114761} [115114]: if (setjmp(png_jmpbuf(png_ptr))) { png_destroy_write_struct(&png_ptr, &info_ptr); fclose(fp); return (ERROR); } ... return; If you would rather avoid the complexity of setjmp/longjmp issues, you can compile libpng with PNG_NO_SETJMP, in which case errors will result in a call to PNG_ABORT() which defaults to abort().
*****************************************************************
========================= CLASS #12 =============================
(132) {17707} [17836]: You can #define PNG_ABORT() to a function that does something more useful than abort(), as long as your function does not return.
(657) {115116} [115245]: You can #define PNG_ABORT() to a function that does something more useful than abort(), as long as your function does not return.
*****************************************************************
========================= CLASS #13 =============================
(134) {17878} [17934]: The default for libpng is to use the C function fread().
(663) {116008} [116065]: The default for libpng is to use the C function fwrite().
*****************************************************************
========================= CLASS #14 =============================
(135) {17936} [18020]: If you use this, you will need to pass a valid FILE * in the function png_init_io().
(664) {116067} [116151]: If you use this, you will need to pass a valid FILE * in the function png_init_io().
*****************************************************************
========================= CLASS #15 =============================
(136) {18022} [18069]: Be sure that the file is opened in binary mode.
(665) {116153} [116200]: Be sure that the file is opened in binary mode.
*****************************************************************
========================= CLASS #16 =============================
(145) {20041} [20151]: Setting up callback code You can set up a callback function to handle any unknown chunks in the input stream.
(600) {105453} [105515]: You set up these callbacks with png_set_progressive_read_fn().
*****************************************************************
========================= CLASS #17 =============================
(152) {21892} [22050]: At this point, you can set up a callback function that will be called after each row has been read, which you can use to control a progress meter or the like.
(668) {116652} [116830]: Write callbacks At this point, you can set up a callback function that will be called after each row has been written, which you can use to control a progress meter or the like.
*****************************************************************
========================= CLASS #18 =============================
(153) {22052} [22083]: It's demonstrated in pngtest.c.
(669) {116832} [116863]: It's demonstrated in pngtest.c.
*****************************************************************
========================= CLASS #19 =============================
(154) {22084} [22552]: You must supply a function void read_row_callback(png_structp png_ptr, png_uint_32 row, int pass); { /* put your code here */ } (You can give it another name that you like instead of "read_row_callback") To inform libpng about your function, use png_set_read_status_fn(png_ptr, read_row_callback); When this function is called the row has already been completely processed and the 'row' and 'pass' refer to the next row to be handled.
(670) {116864} [117308]: You must supply a function void write_row_callback(png_structp png_ptr, png_uint_32 row, int pass); { /* put your code here */ } (You can give it another name that you like instead of "write_row_callback") To inform libpng about your function, use png_set_write_status_fn(png_ptr, write_row_callback); When this function is called the row has already been completely processed and it has also been written out.
(671) {117310} [117367]: The 'row' and 'pass' refer to the next row to be handled.
*****************************************************************
========================= CLASS #20 =============================
(155) {22554} [22688]: For the non-interlaced case the row that was just handled is simply one less than the passed in row number, and pass will always be 0.
(672) {117369} [117503]: For the non-interlaced case the row that was just handled is simply one less than the passed in row number, and pass will always be 0.
*****************************************************************
========================= CLASS #21 =============================
(156) {22690} [22843]: For the interlaced case the same applies unless the row value is 0, in which case the row just handled was the last one from one of the preceding passes.
(673) {117505} [117658]: For the interlaced case the same applies unless the row value is 0, in which case the row just handled was the last one from one of the preceding passes.
*****************************************************************
========================= CLASS #22 =============================
(157) {22845} [23069]: Because interlacing may skip a pass you cannot be sure that the preceding pass is just 'pass-1'; if you really need to know what the last pass is record (row,pass) from the callback and use the last recorded value each time.
(674) {117660} [117884]: Because interlacing may skip a pass you cannot be sure that the preceding pass is just 'pass-1', if you really need to know what the last pass is record (row,pass) from the callback and use the last recorded value each time.
*****************************************************************
========================= CLASS #23 =============================
(158) {23071} [23164]: As with the user transform you can find the output row using the PNG_ROW_FROM_PASS_ROW macro.
(675) {117886} [117979]: As with the user transform you can find the output row using the PNG_ROW_FROM_PASS_ROW macro.
*****************************************************************
========================= CLASS #24 =============================
(232) {35960} [36002]: See the PNG specification for more detail.
(397) {68773} [68816]: See the PNG specification for more details.
*****************************************************************
========================= CLASS #25 =============================
(317) {48391} [49939]: You can use the high-level interface if (a) you are willing to read the entire image into memory, and (b) the input transformations you want to do are limited to the following set: PNG_TRANSFORM_IDENTITY No transformation PNG_TRANSFORM_SCALE_16 Strip 16-bit samples to 8-bit accurately PNG_TRANSFORM_STRIP_16 Chop 16-bit samples to 8-bit less accurately PNG_TRANSFORM_STRIP_ALPHA Discard the alpha channel PNG_TRANSFORM_PACKING Expand 1, 2 and 4-bit samples to bytes PNG_TRANSFORM_PACKSWAP Change order of packed pixels to LSB first PNG_TRANSFORM_EXPAND Perform set_expand() PNG_TRANSFORM_INVERT_MONO Invert monochrome images PNG_TRANSFORM_SHIFT Normalize pixels to the sBIT depth PNG_TRANSFORM_BGR Flip RGB to BGR, RGBA to BGRA PNG_TRANSFORM_SWAP_ALPHA Flip RGBA to ARGB or GA to AG PNG_TRANSFORM_INVERT_ALPHA Change alpha from opacity to transparency PNG_TRANSFORM_SWAP_ENDIAN Byte-swap 16-bit samples PNG_TRANSFORM_GRAY_TO_RGB Expand grayscale samples to RGB (or GA to RGBA) PNG_TRANSFORM_EXPAND_16 Expand samples to 16 bits (This excludes setting a background color, doing gamma transformation, quantizing, and setting filler.)
(781) {139793} [140625]: PNG_TRANSFORM_IDENTITY No transformation PNG_TRANSFORM_PACKING Pack 1, 2 and 4-bit samples PNG_TRANSFORM_PACKSWAP Change order of packed pixels to LSB first PNG_TRANSFORM_INVERT_MONO Invert monochrome images PNG_TRANSFORM_SHIFT Normalize pixels to the sBIT depth PNG_TRANSFORM_BGR Flip RGB to BGR, RGBA to BGRA PNG_TRANSFORM_SWAP_ALPHA Flip RGBA to ARGB or GA to AG PNG_TRANSFORM_INVERT_ALPHA Change alpha from opacity to transparency PNG_TRANSFORM_SWAP_ENDIAN Byte-swap 16-bit samples PNG_TRANSFORM_STRIP_FILLER Strip out filler bytes (deprecated).
*****************************************************************
========================= CLASS #26 =============================
(320) {50302} [50352]: (The final parameter of this call is not yet used.
(784) {141307} [141357]: (The final parameter of this call is not yet used.
*****************************************************************
========================= CLASS #27 =============================
(321) {50354} [50447]: Someday it might point to transformation parameters required by some future input transform.)
(785) {141359} [141453]: Someday it might point to transformation parameters required by some future output transform.)
*****************************************************************
========================= CLASS #28 =============================
(322) {50449} [50552]: You must use png_transforms and not call any png_set_transform() functions when you use png_read_png().
(786) {141455} [141559]: You must use png_transforms and not call any png_set_transform() functions when you use png_write_png().
*****************************************************************
========================= CLASS #29 =============================
(342) {53472} [53563]: height - holds the height of the image in pixels (up to 2^31).
(697) {122089} [122180]: height - holds the height of the image in pixels (up to 2^31).
*****************************************************************
========================= CLASS #30 =============================
(343) {53569} [53656]: bit_depth - holds the bit depth of one of the image channels.
(698) {122186} [122273]: bit_depth - holds the bit depth of one of the image channels.
*****************************************************************
========================= CLASS #31 =============================
(344) {53658} [53767]: (valid values are 1, 2, 4, 8, 16 and depend also on the color_type.
(699) {122295} [122404]: (valid values are 1, 2, 4, 8, 16 and depend also on the color_type.
*****************************************************************
========================= CLASS #32 =============================
(345) {53769} [53830]: See also significant bits (sBIT) below).
(700) {122406} [122467]: See also significant bits (sBIT) below).
*****************************************************************
========================= CLASS #33 =============================
(346) {53836} [53927]: color_type - describes which color/alpha channels are present.
(701) {122473} [122560]: color_type - describes which color/alpha channels are present.
*****************************************************************
========================= CLASS #34 =============================
(347) {53949} [55099]: PNG_COLOR_TYPE_GRAY (bit depths 1, 2, 4, 8, 16) PNG_COLOR_TYPE_GRAY_ALPHA (bit depths 8, 16) PNG_COLOR_TYPE_PALETTE (bit depths 1, 2, 4, 8) PNG_COLOR_TYPE_RGB (bit_depths 8, 16) PNG_COLOR_TYPE_RGB_ALPHA (bit_depths 8, 16) PNG_COLOR_MASK_PALETTE PNG_COLOR_MASK_COLOR PNG_COLOR_MASK_ALPHA interlace_type - (PNG_INTERLACE_NONE or PNG_INTERLACE_ADAM7) compression_type - (must be PNG_COMPRESSION_TYPE_BASE for PNG 1.0) filter_method - (must be PNG_FILTER_TYPE_BASE for PNG 1.0, and can also be PNG_INTRAPIXEL_DIFFERENCING if the PNG datastream is embedded in a MNG-1.0 datastream) Any of width, height, color_type, bit_depth, interlace_type, compression_type, or filter_method can be NULL if you are not interested in their values.
(702) {122582} [123711]: PNG_COLOR_TYPE_GRAY (bit depths 1, 2, 4, 8, 16) PNG_COLOR_TYPE_GRAY_ALPHA (bit depths 8, 16) PNG_COLOR_TYPE_PALETTE (bit depths 1, 2, 4, 8) PNG_COLOR_TYPE_RGB (bit_depths 8, 16) PNG_COLOR_TYPE_RGB_ALPHA (bit_depths 8, 16) PNG_COLOR_MASK_PALETTE PNG_COLOR_MASK_COLOR PNG_COLOR_MASK_ALPHA interlace_type - PNG_INTERLACE_NONE or PNG_INTERLACE_ADAM7 compression_type - (must be PNG_COMPRESSION_TYPE_DEFAULT) filter_method - (must be PNG_FILTER_TYPE_DEFAULT or, if you are writing a PNG to be embedded in a MNG datastream, can also be PNG_INTRAPIXEL_DIFFERENCING) If you call png_set_IHDR(), the call must appear before any of the other png_set_*() functions, because they might require access to some of the IHDR settings.
*****************************************************************
========================= CLASS #35 =============================
(361) {59398} [59705]: (PNG_INFO_cHRM) {red,green,blue}_{X,Y,Z} A color space encoding specified using the encoding end points - the CIE tristimulus specification of the intended color of the red, green and blue channels in the PNG RGB data.
(706) {125323} [125609]: {red,green,blue}_{X,Y,Z} A color space encoding specified using the encoding end points - the CIE tristimulus specification of the intended color of the red, green and blue channels in the PNG RGB data.
*****************************************************************
========================= CLASS #36 =============================
(362) {59727} [59806]: The white point is simply the sum of the three end points.
(707) {125611} [125690]: The white point is simply the sum of the three end points.
*****************************************************************
========================= CLASS #37 =============================
(363) {59807} [60081]: (PNG_INFO_cHRM) png_get_sRGB(png_ptr, info_ptr, &srgb_intent); srgb_intent - the rendering intent (PNG_INFO_sRGB) The presence of the sRGB chunk means that the pixel data is in the sRGB color space.
(708) {125696} [125948]: png_set_sRGB(png_ptr, info_ptr, srgb_intent); srgb_intent - the rendering intent (PNG_INFO_sRGB) The presence of the sRGB chunk means that the pixel data is in the sRGB color space.
(712) {126496} [126769]: png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, srgb_intent); srgb_intent - the rendering intent (PNG_INFO_sRGB) The presence of the sRGB chunk means that the pixel data is in the sRGB color space.
*****************************************************************
========================= CLASS #38 =============================
(364) {60083} [60182]: This chunk also implies specific values of gAMA and cHRM.
(709) {125970} [126048]: This chunk also implies specific values of gAMA and cHRM.
*****************************************************************
========================= CLASS #39 =============================
(366) {60321} [60430]: compression_type - The compression type; always PNG_COMPRESSION_TYPE_BASE for PNG 1.0.
(715) {127121} [127230]: compression_type - The compression type; always PNG_COMPRESSION_TYPE_BASE for PNG 1.0.
*****************************************************************
========================= CLASS #40 =============================
(367) {60454} [60525]: You may give NULL to this argument to ignore it.
(716) {127254} [127325]: You may give NULL to this argument to ignore it.
*****************************************************************
========================= CLASS #41 =============================
(368) {60531} [60623]: profile - International Color Consortium color profile data.
(717) {127331} [127423]: profile - International Color Consortium color profile data.
*****************************************************************
========================= CLASS #42 =============================
(369) {60624} [60641]: May contain NULs.
(718) {127424} [127441]: May contain NULs.
*****************************************************************
========================= CLASS #43 =============================
(370) {60647} [60698]: proflen - length of profile data in bytes.
(719) {127447} [127498]: proflen - length of profile data in bytes.
*****************************************************************
========================= CLASS #44 =============================
(371) {60704} [62587]: png_get_sBIT(png_ptr, info_ptr, &sig_bit); sig_bit - the number of significant bits for (PNG_INFO_sBIT) each of the gray, red, green, and blue channels, whichever are appropriate for the given color type (png_color_16) png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans, &trans_color); trans_alpha - array of alpha (transparency) entries for palette (PNG_INFO_tRNS) num_trans - number of transparent entries (PNG_INFO_tRNS) trans_color - graylevel or color sample values of the single transparent color for non-paletted images (PNG_INFO_tRNS) png_get_hIST(png_ptr, info_ptr, &hist); (PNG_INFO_hIST) hist - histogram of palette (array of png_uint_16) png_get_tIME(png_ptr, info_ptr, &mod_time); mod_time - time image was last modified (PNG_VALID_tIME) png_get_bKGD(png_ptr, info_ptr, &background); background - background color (of type png_color_16p) (PNG_VALID_bKGD) valid 16-bit red, green and blue values, regardless of color_type num_comments = png_get_text(png_ptr, info_ptr, &text_ptr, &num_text); num_comments - number of comments text_ptr - array of png_text holding image comments text_ptr[i].compression - type of compression used on "text" PNG_TEXT_COMPRESSION_NONE PNG_TEXT_COMPRESSION_zTXt PNG_ITXT_COMPRESSION_NONE PNG_ITXT_COMPRESSION_zTXt text_ptr[i].key - keyword for comment.
(720) {127504} [129205]: png_set_sBIT(png_ptr, info_ptr, sig_bit); sig_bit - the number of significant bits for (PNG_INFO_sBIT) each of the gray, red, green, and blue channels, whichever are appropriate for the given color type (png_color_16) png_set_tRNS(png_ptr, info_ptr, trans_alpha, num_trans, trans_color); trans_alpha - array of alpha (transparency) entries for palette (PNG_INFO_tRNS) num_trans - number of transparent entries (PNG_INFO_tRNS) trans_color - graylevel or color sample values (in order red, green, blue) of the single transparent color for non-paletted images (PNG_INFO_tRNS) png_set_hIST(png_ptr, info_ptr, hist); hist - histogram of palette (array of png_uint_16) (PNG_INFO_hIST) png_set_tIME(png_ptr, info_ptr, mod_time); mod_time - time image was last modified (PNG_VALID_tIME) png_set_bKGD(png_ptr, info_ptr, background); background - background color (of type png_color_16p) (PNG_VALID_bKGD) png_set_text(png_ptr, info_ptr, text_ptr, num_text); text_ptr - array of png_text holding image comments text_ptr[i].compression - type of compression used on "text" PNG_TEXT_COMPRESSION_NONE PNG_TEXT_COMPRESSION_zTXt PNG_ITXT_COMPRESSION_NONE PNG_ITXT_COMPRESSION_zTXt text_ptr[i].key - keyword for comment.
*****************************************************************
========================= CLASS #45 =============================
(372) {62589} [62643]: Must contain 1-79 characters.
(721) {129207} [129253]: Must contain 1-79 characters.
*****************************************************************
========================= CLASS #46 =============================
(373) {62649} [62728]: text_ptr[i].text - text comments for current keyword.
(722) {129258} [129337]: text_ptr[i].text - text comments for current keyword.
*****************************************************************
========================= CLASS #47 =============================
(375) {62749} [63052]: text_ptr[i].text_length - length of text string, after decompression, 0 for iTXt text_ptr[i].itxt_length - length of itxt string, after decompression, 0 for tEXt/zTXt text_ptr[i].lang - language of comment (empty string for unknown).
(724) {129365} [129667]: text_ptr[i].text_length - length of text string, after decompression, 0 for iTXt text_ptr[i].itxt_length - length of itxt string, after decompression, 0 for tEXt/zTXt text_ptr[i].lang - language of comment (NULL or empty for unknown).
*****************************************************************
========================= CLASS #48 =============================
(377) {63157} [63306]: Note that the itxt_length, lang, and lang_key members of the text_ptr structure only exist when the library is built with iTXt chunk support.
(726) {129782} [129931]: Note that the itxt_length, lang, and lang_key members of the text_ptr structure only exist when the library is built with iTXt chunk support.
*****************************************************************
========================= CLASS #49 =============================
(378) {63308} [63392]: Prior to libpng-1.4.0 the library was built by default without iTXt support.
(727) {129933} [130017]: Prior to libpng-1.4.0 the library was built by default without iTXt support.
*****************************************************************
========================= CLASS #50 =============================
(379) {63393} [63564]: Also note that when iTXt is supported, they contain NULL pointers when the "compression" field contains PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt.
(728) {130018} [130189]: Also note that when iTXt is supported, they contain NULL pointers when the "compression" field contains PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt.
*****************************************************************
========================= CLASS #51 =============================
(384) {64278} [66166]: png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y, &unit_type); offset_x - positive offset from the left edge of the screen (can be negative) offset_y - positive offset from the top edge of the screen (can be negative) unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y, &unit_type); res_x - pixels/unit physical resolution in x direction res_y - pixels/unit physical resolution in x direction unit_type - PNG_RESOLUTION_UNKNOWN, PNG_RESOLUTION_METER png_get_sCAL(png_ptr, info_ptr, &unit, &width, &height) unit - physical scale units (an integer) width - width of a pixel in physical scale units height - height of a pixel in physical scale units (width and height are doubles) png_get_sCAL_s(png_ptr, info_ptr, &unit, &width, &height) unit - physical scale units (an integer) width - width of a pixel in physical scale units (expressed as a string) height - height of a pixel in physical scale units (width and height are strings like "2.54") num_unknown_chunks = png_get_unknown_chunks(png_ptr, info_ptr, &unknowns) unknowns - array of png_unknown_chunk structures holding unknown chunks unknowns[i].name - name of unknown chunk unknowns[i].data - data of unknown chunk unknowns[i].size - size of unknown chunk's data unknowns[i].location - position of chunk in file The value of "i" corresponds to the order in which the chunks were read from the PNG file or inserted with the png_set_unknown_chunks() function.
(731) {130553} [132506]: png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type); offset_x - positive offset from the left edge of the screen offset_y - positive offset from the top edge of the screen unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type); res_x - pixels/unit physical resolution in x direction res_y - pixels/unit physical resolution in y direction unit_type - PNG_RESOLUTION_UNKNOWN, PNG_RESOLUTION_METER png_set_sCAL(png_ptr, info_ptr, unit, width, height) unit - physical scale units (an integer) width - width of a pixel in physical scale units height - height of a pixel in physical scale units (width and height are doubles) png_set_sCAL_s(png_ptr, info_ptr, unit, width, height) unit - physical scale units (an integer) width - width of a pixel in physical scale units expressed as a string height - height of a pixel in physical scale units (width and height are strings like "2.54") png_set_unknown_chunks(png_ptr, info_ptr, &unknowns, num_unknowns) unknowns - array of png_unknown_chunk structures holding unknown chunks unknowns[i].name - name of unknown chunk unknowns[i].data - data of unknown chunk unknowns[i].size - size of unknown chunk's data unknowns[i].location - position to write chunk in file 0: do not write chunk PNG_HAVE_IHDR: before PLTE PNG_HAVE_PLTE: before IDAT PNG_AFTER_IDAT: after IDAT The "location" member is set automatically according to what part of the output file has already been written.
*****************************************************************
========================= CLASS #52 =============================
(401) {69088} [69236]: The text_ptr is an array of png_text structures, each holding a pointer to a language string, a pointer to a keyword and a pointer to a text string.
(735) {132887} [132927]: text is an array of png_text structures.
*****************************************************************
========================= CLASS #53 =============================
(407) {69830} [69923]: The various ways to transform the data will be described in the order that they should occur.
(794) {143130} [143223]: The various ways to transform the data will be described in the order that they should occur.
*****************************************************************
========================= CLASS #54 =============================
(408) {69925} [70077]: This is important, as some of these change the color type and/or bit depth of the data, and some others only work on certain color types and bit depths.
(795) {143225} [143377]: This is important, as some of these change the color type and/or bit depth of the data, and some others only work on certain color types and bit depths.
*****************************************************************
========================= CLASS #55 =============================
(454) {76323} [76408]: "P" means the transformation is obtained by png_set_expand_palette_to_rgb().
(455) {76414} [76476]: "p" means the transformation is obtained by png_set_packing().
*****************************************************************
========================= CLASS #56 =============================
(462) {77088} [77156]: In PNG files, the alpha channel in an image is the level of opacity.
(790) {141889} [141957]: In PNG files, the alpha channel in an image is the level of opacity.
*****************************************************************
========================= CLASS #57 =============================
(463) {77158} [77625]: If you need the alpha channel in an image to be the level of transparency instead of opacity, you can invert the alpha channel (or the tRNS chunk data) after it's read, so that 0 is fully opaque and 255 (in 8-bit or paletted images) or 65535 (in 16-bit images) is fully transparent, with png_set_invert_alpha(png_ptr); PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as they can, resulting in, for example, 8 pixels per byte for 1 bit files.
(801) {144062} [144204]: PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as they can, resulting in, for example, 8 pixels per byte for 1 bit files.
*****************************************************************
========================= CLASS #58 =============================
(469) {78368} [78608]: This code changes the storage of the pixels to blue, green, red: if (color_type == PNG_COLOR_TYPE_RGB || color_type == PNG_COLOR_TYPE_RGB_ALPHA) png_set_bgr(png_ptr); PNG files store RGB pixels packed into 3 or 6 bytes.
(798) {143616} [143668]: PNG files store RGB pixels packed into 3 or 6 bytes.
*****************************************************************
========================= CLASS #59 =============================
(476) {79638} [79697]: The png_set_add_alpha() function was added in libpng-1.2.7.
(1102) {193717} [193776]: The png_set_add_alpha() function was added at libpng-1.2.7.
*****************************************************************
========================= CLASS #60 =============================
(504) {86605} [87051]: The following code will reverse this (make black be one and white be zero): if (bit_depth == 1 && color_type == PNG_COLOR_TYPE_GRAY) png_set_invert_mono(png_ptr); This function can also be used to invert grayscale and gray-alpha images: if (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA) png_set_invert_mono(png_ptr); PNG files store 16-bit pixels in network byte order (big-endian, ie.
(806) {145211} [145314]: png_set_shift(png_ptr, &sig_bit); PNG files store 16-bit pixels in network byte order (big-endian, ie.
*****************************************************************
========================= CLASS #61 =============================
(505) {87052} [87081]: most significant bits first).
(807) {145315} [145344]: most significant bits first).
*****************************************************************
========================= CLASS #62 =============================
(507) {87151} [87566]: least significant bits first, the way PCs store them): if (bit_depth == 16) png_set_swap(png_ptr); If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you need to change the order the pixels are packed into bytes, you can use: if (bit_depth < 8) png_set_packswap(png_ptr); Finally, you can write your own transformation function if none of the existing ones meets your needs.
(809) {145426} [145794]: least significant bits first, the way PCs store them): if (bit_depth > 8) png_set_swap(png_ptr); If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you need to change the order the pixels are packed into bytes, you can use: if (bit_depth < 8) png_set_packswap(png_ptr); PNG files store 3 color pixels in red, green, blue order.
*****************************************************************
========================= CLASS #63 =============================
(508) {87568} [87845]: This is done by setting a callback with png_set_read_user_transform_fn(png_ptr, read_transform_fn); You must supply the function void read_transform_fn(png_structp png_ptr, png_row_infop row_info, png_bytep data) See pngtest.c for a working example.
(812) {146211} [146489]: This is done by setting a callback with png_set_write_user_transform_fn(png_ptr, write_transform_fn); You must supply the function void write_transform_fn(png_structp png_ptr, png_row_infop row_info, png_bytep data) See pngtest.c for a working example.
*****************************************************************
========================= CLASS #64 =============================
(509) {87847} [87935]: Your function will be called after all of the other transformations have been processed.
(813) {146491} [146574]: Your function will be called before any of the other transformations are processed.
*****************************************************************
========================= CLASS #65 =============================
(512) {88553} [88635]: With interlaced images the value returned is the row in the input sub-image image.
(815) {146810} [146892]: With interlaced images the value returned is the row in the input sub-image image.
*****************************************************************
========================= CLASS #66 =============================
(513) {88637} [88793]: Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
(816) {146894} [147050]: Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
*****************************************************************
========================= CLASS #67 =============================
(514) {88795} [88891]: The discussion of interlace handling above contains more information on how to use these values.
(817) {147052} [147148]: The discussion of interlace handling above contains more information on how to use these values.
*****************************************************************
========================= CLASS #68 =============================
(515) {88893} [89309]: You can also set up a pointer to a user structure for use by your callback function, and you can inform libpng that your transform function will change the number of channels or bit depth with the function png_set_user_transform_info(png_ptr, user_ptr, user_depth, user_channels); The user's application, not libpng, is responsible for allocating and freeing any memory required for the user structure.
(818) {147150} [147234]: You can also set up a pointer to a user structure for use by your callback function.
*****************************************************************
========================= CLASS #69 =============================
(516) {89311} [89386]: You can retrieve the pointer via the function png_get_user_transform_ptr().
(820) {147418} [147493]: You can retrieve the pointer via the function png_get_user_transform_ptr().
*****************************************************************
========================= CLASS #70 =============================
(531) {91241} [91293]: The simplest way to do this is in one function call.
(828) {148723} [148775]: The simplest way to do this is in one function call.
*****************************************************************
========================= CLASS #71 =============================
(533) {91475} [91533]: You will need to pass in an array of pointers to each row.
(830) {148886} [148944]: You will need to pass in an array of pointers to each row.
*****************************************************************
========================= CLASS #72 =============================
(534) {91535} [91776]: This function automatically handles interlacing, so you don't need to call png_set_interlace_handling() (unless you call png_read_update_info()) or call this function multiple times, or any of that other stuff necessary with png_read_rows().
(831) {148946} [149147]: This function automatically handles interlacing, so you don't need to call png_set_interlace_handling() or call this function multiple times, or any of that other stuff necessary with png_write_rows().
*****************************************************************
========================= CLASS #73 =============================
(535) {91781} [91942]: png_read_image(png_ptr, row_pointers); where row_pointers is: png_bytep row_pointers[height]; You can point to void or char or whatever you use for pixels.
(832) {149153} [149316]: png_write_image(png_ptr, row_pointers); where row_pointers is: png_byte *row_pointers[height]; You can point to void or char or whatever you use for pixels.
*****************************************************************
========================= CLASS #74 =============================
(548) {93990} [94066]: Currently, this is seven, but may change if another interlace type is added.
(841) {150699} [150775]: Currently, this is seven, but may change if another interlace type is added.
*****************************************************************
========================= CLASS #75 =============================
(586) {100989} [102077]: When you are done, you can free all memory allocated by libpng like this: png_destroy_read_struct(&png_ptr, &info_ptr, &end_info); or, if you didn't create an end_info structure, png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL); It is also possible to individually free the info_ptr members that point to libpng-allocated storage with the following function: png_free_data(png_ptr, info_ptr, mask, seq) mask - identifies data to be freed, a mask containing the bitwise OR of one or more of PNG_FREE_PLTE, PNG_FREE_TRNS, PNG_FREE_HIST, PNG_FREE_ICCP, PNG_FREE_PCAL, PNG_FREE_ROWS, PNG_FREE_SCAL, PNG_FREE_SPLT, PNG_FREE_TEXT, PNG_FREE_UNKN, or simply PNG_FREE_ALL seq - sequence number of item to be freed (-1 for all items) This function may be safely called when the relevant storage has already been freed, or has not yet been allocated, or was allocated by the user and not by libpng, and will in those cases do nothing.
(853) {152188} [153178]: png_write_end(png_ptr, info_ptr); When you are done, you can free all memory used by libpng like this: png_destroy_write_struct(&png_ptr, &info_ptr); It is also possible to individually free the info_ptr members that point to libpng-allocated storage with the following function: png_free_data(png_ptr, info_ptr, mask, seq) mask - identifies data to be freed, a mask containing the bitwise OR of one or more of PNG_FREE_PLTE, PNG_FREE_TRNS, PNG_FREE_HIST, PNG_FREE_ICCP, PNG_FREE_PCAL, PNG_FREE_ROWS, PNG_FREE_SCAL, PNG_FREE_SPLT, PNG_FREE_TEXT, PNG_FREE_UNKN, or simply PNG_FREE_ALL seq - sequence number of item to be freed (-1 for all items) This function may be safely called when the relevant storage has already been freed, or has not yet been allocated, or was allocated by the user and not by libpng, and will in those cases do nothing.
*****************************************************************
========================= CLASS #76 =============================
(587) {102078} [102178]: The "seq" parameter is ignored if only one item of the selected data type, such as PLTE, is allowed.
(854) {153179} [153279]: The "seq" parameter is ignored if only one item of the selected data type, such as PLTE, is allowed.
*****************************************************************
========================= CLASS #77 =============================
(588) {102180} [102358]: If "seq" is not -1, and multiple items are allowed for the data type identified in the mask, such as text or sPLT, only the n'th item in the structure is freed, where n is "seq".
(855) {153281} [153459]: If "seq" is not -1, and multiple items are allowed for the data type identified in the mask, such as text or sPLT, only the n'th item in the structure is freed, where n is "seq".
*****************************************************************
========================= CLASS #78 =============================
(589) {102360} [102442]: The default behavior is only to free data that was allocated internally by libpng.
(857) {153626} [153708]: The default behavior is only to free data that was allocated internally by libpng.
*****************************************************************
========================= CLASS #79 =============================
(590) {102444} [102997]: This can be changed, so that libpng will not free the data, or so that it will free data that was allocated by the user with png_malloc() or png_calloc() and passed in via a png_set_*() function, with png_data_freer(png_ptr, info_ptr, freer, mask) freer - one of PNG_DESTROY_WILL_FREE_DATA PNG_SET_WILL_FREE_DATA PNG_USER_WILL_FREE_DATA mask - which data elements are affected same choices as in png_free_data() This function only affects data that has already been allocated.
(860) {154867} [154931]: This function only affects data that has already been allocated.
*****************************************************************
========================= CLASS #80 =============================
(591) {102998} [103340]: You can call this function after reading the PNG data but before calling any png_set_*() functions, to control whether the user or the png_set_*() function is responsible for freeing any existing data that might be present, and again after the png_set_*() functions to control whether the user or png_destroy_*() is supposed to free the data.
(861) {154932} [155082]: You can call this function before calling after the png_set_*() functions to control whether the user or png_destroy_*() is supposed to free the data.
*****************************************************************
========================= CLASS #81 =============================
(592) {103342} [103613]: When the user assumes responsibility for libpng-allocated data, the application must use png_free() to free it, and when the user transfers responsibility to libpng for data that the user has allocated, the user must have used png_malloc() or png_calloc() to allocate it.
(862) {155083} [155354]: When the user assumes responsibility for libpng-allocated data, the application must use png_free() to free it, and when the user transfers responsibility to libpng for data that the user has allocated, the user must have used png_malloc() or png_calloc() to allocate it.
*****************************************************************
========================= CLASS #82 =============================
(594) {103912} [104208]: If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword separately, do not transfer responsibility for freeing text_ptr to libpng, because when libpng fills a png_text structure it combines these members with the key member, and png_free_data() will free only text_ptr.key.
(863) {155356} [155652]: If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword separately, do not transfer responsibility for freeing text_ptr to libpng, because when libpng fills a png_text structure it combines these members with the key member, and png_free_data() will free only text_ptr.key.
*****************************************************************
========================= CLASS #83 =============================
(595) {104210} [104363]: Similarly, if you transfer responsibility for free'ing text_ptr from libpng to your application, your application must not separately free those members.
(864) {155654} [155807]: Similarly, if you transfer responsibility for free'ing text_ptr from libpng to your application, your application must not separately free those members.
*****************************************************************
========================= CLASS #84 =============================
(597) {104449} [105148]: If you need to turn the flag off for a chunk that was freed by your application instead of by libpng, you can use png_set_invalid(png_ptr, info_ptr, mask); mask - identifies the chunks to be made invalid, containing the bitwise OR of one or more of PNG_INFO_gAMA, PNG_INFO_sBIT, PNG_INFO_cHRM, PNG_INFO_PLTE, PNG_INFO_tRNS, PNG_INFO_bKGD, PNG_INFO_hIST, PNG_INFO_pHYs, PNG_INFO_oFFs, PNG_INFO_tIME, PNG_INFO_pCAL, PNG_INFO_sRGB, PNG_INFO_iCCP, PNG_INFO_sPLT, PNG_INFO_sCAL, PNG_INFO_IDAT For a more compact example of reading a PNG image, see the file example.c.
(865) {155808} [155882]: For a more compact example of writing a PNG image, see the file example.c.
*****************************************************************
========================= CLASS #85 =============================
(658) {115247} [115318]: Checking for invalid palette index on write was added at libpng 1.5.10.
(1157) {200766} [200837]: Checking for invalid palette index on write was added at libpng 1.5.10.
*****************************************************************
========================= CLASS #86 =============================
(659) {115320} [115401]: If a pixel contains an invalid (out-of-range) index libpng issues a benign error.
(1158) {200839} [200920]: If a pixel contains an invalid (out-of-range) index libpng issues a benign error.
*****************************************************************
========================= CLASS #87 =============================
(660) {115403} [115792]: This is enabled by default because this condition is an error according to the PNG specification, Clause 11.3.2, but the error can be ignored in each png_ptr with png_set_check_for_invalid_index(png_ptr, 0); If the error is ignored, or if png_benign_error() treats it as a warning, any invalid pixels are written as-is by the encoder, resulting in an invalid PNG datastream as output.
(1159) {200922} [201268]: This is enabled by default because this condition is an error according to the PNG specification, Clause 11.3.2, but the error can be ignored in each png_ptr with png_set_check_for_invalid_index(png_ptr, allowed); allowed - one of 0: disable benign error (accept the invalid data without warning).
(1161) {201401} [201570]: If the error is ignored, or if png_benign_error() treats it as a warning, any invalid pixels are decoded as opaque black by the decoder and written as-is by the encoder.
*****************************************************************
========================= CLASS #88 =============================
(826) {148629} [148687]: Writing the image data That's it for the transformations.
(827) {148689} [148722]: Now you can write the image data.
*****************************************************************
========================= CLASS #89 =============================
(869) {156460} [156717]: To read a PNG file using the simplified API: 1) Declare a 'png_image' structure (see below) on the stack, set the version field to PNG_IMAGE_VERSION and the 'opaque' pointer to NULL (this is REQUIRED, your program may crash if you don't do it.)
(876) {157495} [157625]: To write a PNG file using the simplified API: 1) Declare a 'png_image' structure on the stack and memset() it to all zero.
*****************************************************************
========================= CLASS #90 =============================
(895) {160441} [160707]: When the simplified API needs to convert between sRGB and linear colorspaces, the actual sRGB transfer curve defined in the sRGB specification (see the article at http://en.wikipedia.org/wiki/SRGB) is used, not the gamma=1/2.2 approximation used elsewhere in libpng.
(969) {171941} [172207]: When the simplified API needs to convert between sRGB and linear colorspaces, the actual sRGB transfer curve defined in the sRGB specification (see the article at http://en.wikipedia.org/wiki/SRGB) is used, not the gamma=1/2.2 approximation used elsewhere in libpng.
*****************************************************************
========================= CLASS #91 =============================
(990) {175768} [176131]: These functions also provide a void pointer that can be retrieved via mem_ptr=png_get_mem_ptr(png_ptr); Your replacement memory functions must have prototypes as follows: png_voidp malloc_fn(png_structp png_ptr, png_alloc_size_t size); void free_fn(png_structp png_ptr, png_voidp ptr); Your malloc_fn() must return NULL in case of failure.
(996) {176808} [176908]: These functions also provide a void pointer that can be retrieved via the function png_get_io_ptr().
*****************************************************************
========================= CLASS #92 =============================
(1018) {180754} [180876]: As of libpng-1.6.0, the default condition is to treat benign errors as warnings while reading and as errors while writing.
(1264) {217866} [217990]: The default condition for benign_errors is now to treat benign errors as warnings while reading and as errors while writing.
*****************************************************************
========================= CLASS #93 =============================
(1027) {181688} [181746]: More details can be found in the comments inside the code.
(1032) {182323} [182388]: More details can be found in the comments inside the code itself.
*****************************************************************
========================= CLASS #94 =============================
(1095) {193043} [193113]: However, we never got around to actually numbering the error messages.
(1143) {199364} [199491]: Support for numbered error messages was removed by default, since we never got around to actually numbering the error messages.
*****************************************************************
========================= CLASS #95 =============================
(1108) {195520} [195580]: It has been deprecated since libpng-1.0.16 and libpng-1.2.6.
(1131) {197627} [197669]: It has been deprecated since libpng-1.0.9.
*****************************************************************
========================= CLASS #96 =============================
(1110) {195714} [195860]: The function png_set_gray_1_2_4_to_8() which also expands tRNS to alpha was replaced with png_set_expand_gray_1_2_4_to_8() which does not.
(1135) {198098} [198149]: The function png_set_gray_1_2_4_to_8() was removed.
*****************************************************************
========================= CLASS #97 =============================
(1138) {198481} [198625]: Unfortunately, from libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the function) incorrectly returned a value of type png_uint_32.
(1155) {200537} [200713]: Changes to Libpng from version 1.4.x to 1.5.x From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the function) incorrectly returned a value of type png_uint_32.
*****************************************************************
========================= CLASS #98 =============================
(1170) {202815} [202908]: It does not matter whether this is placed prior to or after the '"#include png.h"' directive.
(1247) {214744} [214837]: It does not matter whether this is placed prior to or after the '#include "png.h"' directive.
*****************************************************************
